%===================================== CHAP 6 =================================

\chapter{Testing, Not finished}

\section{Test description}

The sections below covers the different test phases. It explains the different tests, as well as discusses the reasoning and usage of the different test methodologies.

\subsection{Unit Testing}

A unit test is a specific test written for testing all method in a class (unit). It is written to confirm that the methods will always act as intended, even if other parts of the program code is changed. Unit tests were used on the parts of the system containing logical operations and calculations. Unit tests does not however exclude the possibility of errors. It only reduces the amount of cases where an error might occur.

Initially, the plan was to use test-driven development as often as possible. This proved difficult. In a lot of cases it was hard to know exactly which units were needed, and as the group learned, the units changed. Thus, tests that initially were written to verify units, were changed later on.

Units of the system responsible for inter-thread communication, task processing and queuing were excluded from unit tests. This is due to the group not having the necessary time or experience to write proper unit tests for these conditions.

\subsection{Integration testing}

Integration testing considers testing where individual modules of the software are grouped. It is a black-box test, in which major parts of the system are tested. The goal of the tests was to make sure that the major parts of the system were working as individual modules. In this case, integration testing was used for the protocols and the core services of the system.

\subsection{Profiling}

Profiling is a way to dynamically analyze the program while it is running. This is done to get an overview of where the resources are used. The method is useful to find bottlenecks and inefficient methods in the program. The software was run as a server instance, and had a possibility for high load on a wide variety of hardware. Profiling was useful to find the parts of the system that had performance issues. It was performed each time some part of the system was completed.

\subsection{System testing}

System testing is performed to ensure that the product meets its requirements. It is a black-box test, often performed upon completion of the product. The goal is to go through all the requirements, and ensure that they are met and working as intended. System testing was performed prior to the acceptance test with the customer.

\subsection{Acceptance Testing}

Acceptance testing was used as the final test conducted with the customer. Acceptance testing is generally concerned with whether or not the requirements of the system are met in a satisfiable way. The inner workings of the system was ignored, and the focus was the usability of the system itself. Due to the fact that the customer was located in Oslo, the acceptance test was combined with the delivery of the product. 

\section{Test Execution}

The following sections discusses how tests were planned and executed for each part of the system. The goal is to give a general overview of how tests were conducted and written.

\subsection{Unit testing} 

As previously stated, unit tests were written for parts of the system containing logical operations and calculations. Other components of the system were tested in the integration and system test phases.

The actual execution of the unit tests were automated using our continuous integration solution, Jenkins, in combination with the Jenkins TestNG plugin.

The metric the group chose to represent this section of the report is test coverage. Test coverage is the percentage of code blocks covered by a corresponding test. All the unit tests passed validation, hence it is somewhat irrelevant to include a per-unit table of tests in this section. It is more descriptive to see how much of the code base is covered by unit tests.

The following list provides an overview of the different packages in the product and their test coverage.

\begin{enumerate}
\item core - ??\%
\item core.event - ??\%
\item core.messaging - ??\%
\item core.subscription - ??\%
\item core.topic - ??\%
\item db - ??\%
\item examples - ??\%
\item exceptions - ??\%
\item protocol.wsn - ??\%
\item protocol.amqp - ??\%
\item web - ??\%
\end{enumerate}

The source code, including all the test methods can be found in the "test" package of the application.

\subsection{Integration testing | Incomplete, add tables for remaining components}

Each of the components were tested individually upon completion. For each of the protocols, tests were based on mainly whether or not a message could be correctly sent and received according to protocol standards. Additionally, the messages were tested with regards to length handling and special characters. The tests were performed using two different computers running the system. Following are tables describing the test procedure for each of the components.

\subsubsection{WSN Implementation}

\begin{table}[ht!]
\begin{tabular}{|m{3cm}|m{3cm}|m{3cm}|m{1.5cm}|}
\hline
\textbf{Description} & \textbf{Procedure} & \textbf{Expected result} & \textbf{Result}\\ \hline
Test to see if a message can be sent and received.& Person X sends the message "Hello world" on a topic.& Message "Hello world" received by person Y & Success \\ \hline
x&y&z&f \\ \hline
x&y&z&f \\ \hline
y&z&a&f \\ \hline
\end{tabular}
\end{table}

\subsubsection{AMQP Implementation}

\begin{table}[ht!]
\begin{tabular}{|m{3cm}|m{3cm}|m{3cm}|m{1.5cm}|}
\hline
\textbf{Description} & \textbf{Procedure} & \textbf{Expected result} & \textbf{Result}\\ \hline
x&y&z&f \\ \hline
x&y&z&f \\ \hline
x&y&z&f \\ \hline
y&z&x&f \\ \hline
\end{tabular}
\end{table}

\subsubsection{Core service}

\begin{table}[h]
\begin{tabular}{|m{3cm}|m{3cm}|m{3cm}|m{1.5cm}|}
\hline
\textbf{Description} & \textbf{Procedure} & \textbf{Expected result} & \textbf{Result}\\ \hline
x&y&z&f \\ \hline
x&y&z&f \\ \hline
x&y&z&f \\ \hline
y&z&x&f \\ \hline
\end{tabular}
\end{table}

\subsection{System testing}

System testing was performed based on the requirements for the system. Each of the functional requirements were tested in a procedural manner. Additionally, although no clear requirement were set for performance, it was tested to make sure there were no bottlenecks, and the system was performing fairly well. A table was made for each of the requirements.

\begin{table}[ht!]
\begin{tabular}{|m{4cm}|m{2cm}|m{4cm}|}
\hline
\multicolumn{3}{|c|}{\textbf{FR1, WSN}} \\ \hline
\multicolumn{3}{|c|}{{Test to see if a WSN message can be sent, and received on all protocols}} \\ \hline
\textbf{Procedure} & \textbf{Result} & \textbf{Comments} \\ \hline
Send "Hello World" over the network & OK & Message sent, and received on the correct topic of both protocols. \\ \hline
x&z&y \\ \hline
x&z&y \\ \hline
x&y&z \\ \hline
\end{tabular}
\end{table}

\begin{table}[ht!]
\begin{tabular}{|m{4cm}|m{2cm}|m{4cm}|}
\hline
\multicolumn{3}{|c|}{\textbf{FR2, AMQP}} \\ \hline
\multicolumn{3}{|c|}{{Test to see if an AMQP message can be sent, and received on all protocols}} \\ \hline
\textbf{Procedure} & \textbf{Result} & \textbf{Comments} \\ \hline
Send "Hello World" over the network & x & y \\ \hline
x&z&y \\ \hline
x&z&y \\ \hline
x&y&z \\ \hline
\end{tabular}
\end{table}

\begin{table}[ht!]
\begin{tabular}{|m{4cm}|m{2cm}|m{4cm}|}
\hline
\multicolumn{3}{|c|}{\textbf{FR3, Topic mapping}} \\ \hline
\multicolumn{3}{|c|}{{Test to see if topics can be properly mapped to each other}} \\ \hline
\textbf{Procedure} & \textbf{Result} & \textbf{Comments} \\ \hline
x & x & y \\ \hline
x &z&y \\ \hline
x &z&y \\ \hline
x&y&z \\ \hline
\end{tabular}
\end{table}

\begin{table}[ht!]
\begin{tabular}{|m{4cm}|m{2cm}|m{4cm}|}
\hline
\multicolumn{3}{|c|}{\textbf{FR4, Edit subscription}} \\ \hline
\multicolumn{3}{|c|}{{Test to see if an admin can delete topics, and subscriptions on topic}} \\ \hline
\textbf{Procedure} & \textbf{Result} & \textbf{Comments} \\ \hline
Delete a subscriber on topic "test". & x & y \\ \hline
Delete all subscribers on topic "test" &z&y \\ \hline
Delete topic "test". &z&y \\ \hline
x&y&z \\ \hline
\end{tabular}
\end{table}

\begin{table}[ht!]
\begin{tabular}{|m{4cm}|m{2cm}|m{4cm}|}
\hline
\multicolumn{3}{|c|}{\textbf{FR6, Information}} \\ \hline
\multicolumn{3}{|c|}{{Test to see if the proper information is viewed.}} \\ \hline
\textbf{Procedure} & \textbf{Result} & \textbf{Comments} \\ \hline
Check all information in the interface, see if it matches actual information & x & y \\ \hline
\end{tabular}
\end{table}

\begin{table}[ht!]
\begin{tabular}{|m{4cm}|m{2cm}|m{4cm}|}
\hline
\multicolumn{3}{|c|}{\textbf{FR5, Log in}} \\ \hline
\multicolumn{3}{|c|}{{Test to see if an administrator is able to log in}} \\ \hline
\textbf{Procedure} & \textbf{Result} & \textbf{Comments} \\ \hline
Insert correct username and password & x & y \\ \hline
Insert string with length X in both fields &z&y \\ \hline
Insert script tags in username field X &z&y \\ \hline
x&y&z \\ \hline
\end{tabular}
\end{table}

\subsection{Acceptance test}

The acceptance test was performed prior to the final delivery of the product. The customer went over the requirements step by step, and gave feedback on whether or not they were implemented in a satisfying way.

\subsubsection{Comments}


\clearpage