\chapter{Apache Apollo}
\label{appendix:apache-apollo}

\section{Introduction}
In this section the collected information and impressions of Apache Apollo is listed and analysed. As the research phase was a considerable large part of the project and was in a great degree focused on Apache Apollo, it is considered important.

The customer also indicated that they where very interested in all the research done on message brokers and existing solutions.

This appendix can be used as a standalone document, and may therefore repeat some information that also is mentioned in the main report for OKSE message broker.

\section{About Apollo}
Apache Apollo is a message broker system developed by the Apache foundation. Apollo is considered a "sub" project of Apache ActiveMQ\footnote{\url{http://activemq.apache.org}} and is by the developers own words, the next generation of ActiveMQ. Apollo is, as ActiveMQ a protocol agnostic broker what can freely transfer between the supported protocols. As of this writing, the supported protocol is MQTT, AMQP, STOMP, OpenWire and WebSockets. 

Apollo is developed under, as the name states, the Apache software foundation. Under the research phase, it was observed that most of the commits to the project was done by software developers from Red Hat\footnote{\url{http://www.redhat.com/en}}. The development team of OKSE considered this a positive thing, as they are probably committing to the project, in favor of their customers. 

\section{Key features}

\subsection{Architecture}
The Apollo architecture is built around the idea of having a multi-threaded non-blocking implementation using the Reactor pattern\footnote{\url{http://en.wikipedia.org/wiki/Reactor_pattern}}. The non-blocking approach in a single thread is not a new approach to achieve a high amount of connections and high throughput. It is a well known pattern, used in high performance implementations like the server-side JavaScript implementation NodeJS and the popular web server Nginx. However, the use of a multiple threads that handles jobs non-blocking gives the application the possibility of scaling very well with todays computers with a high core count. 


\subsection{Scala}
As stated by the developers of Apollo, they needed to think differently since all tasks that needs to be executed needs to be non-blocking, and should be lock and wait free. There was also needs for a radical change in the network IO handling. To achieve this goal, the object-functional language Scala\footnote{\url{http://www.scala-lang.org}} was chosen. Scala has many features from functional programming\footnote{\url{http://en.wikipedia.org/wiki/Functional_programming}} and has a good way to express callbacks when writing asynchronous code.

\subsection{Protocol Agnostic}
Apollo has support for the same protocols as ActiveMQ, but the way that it handles conversion between them is rewritten. First because of the need to have all the tasks running asynchronously and the fact that the way ActiveMQ handles this was quite inefficient. 
In ActiveMQ when a message needed to be converted to another protocol other than its origin, the protocol will first be converted to the OpenWire format (can be looked as ActiveMQs internal format), and then to the protocol it will be sent. 
In Apollo the handling of protocol conversation was reimplemented. It now saves a message in its native format until it actually has to convert it to the other protocols. When the conversion is done, it converts directly between the protocols. This is to make sure that no unnecessary computing power is used.

\subsection{Message Swapping}
When running Java application, the Java Virtual Machine is usually configured with a fixed amount of memory. Since a high traffic message service, can end up having millions of messages, smart memory and message queue handling needs to be written. 
In Apollo, message queues that are not going to be needed for a while will be taken out of memory and put in a message store. When the time to use the queue is approaching, the queue will be put back into memory. This gives Apollo the possibility to handle a lot of messages with a limited amount of memory.

\subsection{Modules}
Apollo is written to be very modular. Every single component and protocol is implemented as its own protocol. This is a great feature when considering extendability. 

\section{Points of entry}
YOUR MOM

\subsection{WSN support}

\section{Evaluation for the project}
The first thing that the research time spent on Apollo yielded, is the impression that it is a well written, and very scalable broker.
It definitively had a lot of desired features and would easily be a good foundation to build the product for the customer. The main problem with using Apollo is the complexity. The non-blocking asynchronous approach puts a lot of constraints on the developer and if the developer has not been working with this kinds of pattern earlier, then it is quite hard to wrap around. In addition to the new pattern, the development requires the knowledge of Scala, and some experience with functional programming. 

As the group had a limited amount of time available, and not knowledge to any particular extent on the used programming pattern and language. There was made a decision that the risk of failure was to high to go with Apollo. The possibility of not getting through even the source code and obtaining the knowledge needed was to great with our time frame. 

\section{Evaluation for later use}
Given that the customer has enough time and resources, the group would recommend to evaluate Apollo, and the possibility of extending it too fit the needs of a given project. If scalability and performance is an important part of the feature set, then Apollo or the ideas and patterns Apollo uses should be considered to build the foundation.

\clearpage
